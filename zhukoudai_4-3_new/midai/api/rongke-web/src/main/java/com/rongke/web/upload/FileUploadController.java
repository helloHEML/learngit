package com.rongke.web.upload;import com.rongke.commons.FailException;import com.rongke.commons.JsonResp;import com.rongke.enums.FileType;import com.rongke.utils.ArrayUtils;import com.rongke.web.config.ConfigUtil;import com.rongke.web.config.ConfigsUL;import org.apache.log4j.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.util.ArrayList;import java.util.List;import java.util.UUID;@CrossOrigin@RestController@RequestMapping(value="/api/attachment")public class FileUploadController {    private Logger log = Logger.getLogger(this.getClass());    @Autowired    public ConfigUtil config;    @Autowired    private ConfigsUL configs;    /**     * @param file  文件     * @param fileType  文件类型     * @throws Exception 加密失败     */    @RequestMapping(value="/upload",method = RequestMethod.POST)    @CrossOrigin    public JsonResp batch(@RequestParam(value = "file", required = false) CommonsMultipartFile file, FileType fileType) throws Exception {        if (null == file) {            log.error("batchUpload input empty");            return JsonResp.fa("文件不能为空");        }        if(fileType==null){             fileType=FileType.OTHER;        }        try {            // 文件存储目录            String filePath = fileType.getAbsolutePath();            File rootFolder = new File(filePath);            if (!rootFolder.exists()) {                rootFolder.mkdirs();            }            String realFileName = UUID.randomUUID().toString()                    .replaceAll("-", "");            String originalFileName = file.getOriginalFilename();            int index = originalFileName.lastIndexOf('.');            realFileName += originalFileName.substring(index);            File saveFile = new File(filePath + File.separator                    + realFileName);            file.transferTo(saveFile);            String fileUrl = fileType.getFileUrl() + "/"+ realFileName;            return JsonResp.ok(fileUrl);        } catch (Exception e) {            log.error("uploadSingleFile failed", e);            return JsonResp.fa("文件上传失败");        }    }    /**     * @param files 多文件     * @param type  文件类型     * @throws Exception 加密失败     */    @RequestMapping(value = "/uploadng", method = RequestMethod.POST)    @CrossOrigin    public JsonResp<String[]> uploadng(@RequestParam(value = "files", required = false) MultipartFile[] files, com.rongke.utils.FileType type, HttpServletRequest request)            throws Exception {        if (ArrayUtils.isEmpty(files)) {            throw new FailException("文件至少要有一个");        }        String[] paths = com.rongke.utils.FileType.getPath(type, files.length, request);        String[] urls = new String[files.length];        for (int i = 0; i < paths.length; i++) {            String path = paths[i];            MultipartFile multipartFile = files[i];            // 获取文件的后缀            String suffix;            try {                suffix = multipartFile.getOriginalFilename().substring(multipartFile.getOriginalFilename().lastIndexOf("."));            } catch (Exception e) {                suffix = "";            }            String fileName = UUID.randomUUID().toString();            fileName += suffix;            File saveFile = new File(path + File.separator + fileName);            multipartFile.transferTo(saveFile);            urls[i] = configs.getUploadHost(request, type, saveFile.getParentFile().getName(), saveFile.getName());        }        return new JsonResp<String[]>().data(urls);    }    /**     * @param files 多文件     * @param fileType  文件类型     * @throws Exception 加密失败     */    @RequestMapping(value="/uploadFiles",method = RequestMethod.POST)    @CrossOrigin    public JsonResp uploadFiles(MultipartFile[] files, FileType fileType)            throws Exception {        if (ArrayUtils.isEmpty(files)) {            throw new FailException("文件至少要有一个");        }        if(fileType==null){            fileType=FileType.OTHER;        }        try {            // 文件存储目录            String filePath = fileType.getAbsolutePath();            File rootFolder = new File(filePath);            if (!rootFolder.exists()) {                rootFolder.mkdirs();            }            List<String> fileUrlList = new ArrayList<String>();            for (MultipartFile file : files) {                if (null == file) {                    continue;                }                String realFileName = UUID.randomUUID().toString()                        .replaceAll("-", "");                String originalFileName = file.getOriginalFilename();                int index = originalFileName.lastIndexOf('.');                if (index >= 0) {                    realFileName += originalFileName.substring(index);                }                File saveFile = new File(filePath + File.separator                        + realFileName);                file.transferTo(saveFile);                String fileUrl = fileType.getFileUrl() + "/"+ realFileName;                fileUrlList.add(fileUrl);            }            System.err.println(fileUrlList.toString());            return JsonResp.ok(fileUrlList);        } catch (Exception e) {            log.error("多文件上传失败", e);            return JsonResp.fa(null);        }    }}